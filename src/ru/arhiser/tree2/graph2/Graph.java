package ru.arhiser.tree2.graph2;

/**
 * Класс описывающий граф.
 */
public class Graph {

    /**
     * Поле отвечающее за
     * максимальное количество вершин в графе.
     */
    private int maxN = 10;
    /**
     * !!!Матрица смежности!!!
     * Предполагает использование двумерного массива чисел.
     * У нас обычный граф.
     * Для обычного графа (не ориентированного) матрица смежности
     * симметрична относительно главной диагонали, т.е. если
     * [3][1] = 0, то и [1][3] = 0 (Это видно если нарисовать
     * эту матрицу)
     * Показывает наличие связей между вершинами графа.
     * Есть ли между ними связь или нет.
     * 1 - да, переход есть (связь есть).
     * 0 - нет, перехода нет (связи нет).
     * Инициализируем в конструкторе.
     */
    private int[][] mas;
    /**
     * Список вершин (узлов) графа.
     */
    Vertex[] vertexList;
    /**
     * Счетчик отвечающий за вершины в графе,
     * считает их.
     */
    private int curN;
    /**
     * Стек для обхода графа в глубину.
     * Инициализируем его сразу.
     */
    private MyStack stack = new MyStack();
    /**
     * Очередь для обхода графа в ширину.
     * Инициализируем его сразу.
     */
    private MyQueue queue = new MyQueue();

    /**
     * Конструктор ничего не принимает,
     * просто инициализирует список вершин
     * и матрицу смежности.
     */
    public Graph() {
        vertexList = new Vertex[maxN];
        mas = new int[maxN][maxN];
        curN = 0;
    }

    /**
     * Метод добавляющий вершины в граф.
     *
     * @param name имя вершины.
     */
    public void addVertex(char name) {
        /*Сначала инициализируем Vertex(name),
         * помещаем его в ячейку списка, и затем
         * инкрементирум номер ячейки.*/
        vertexList[curN++] = new Vertex(name);
    }

    /**
     * Метод создающий ребра.
     *
     * @param start начальная вершина.
     * @param end   конечная вершина.
     * @param val   для инициализации матрицы смежности.
     */
    public void addEdge(int start, int end, int val) {
        mas[start][end] = 1; //переход есть.
        mas[end][start] = val; //наличие перехода будет выбрано позже в Runner
    }

    /**
     * Метод проверяет была ли посещена вершина или
     * нет. Возвращает не посещенную вершину.
     *
     * @param v проверяемая текущая вершина.
     * @return не посещенная вершина или -1
     * если все вершины были посещены.
     */
    public int check(int v) {
        /*Цикл идет по всем вершинам*/
        for (int i = 0; i < curN; i++) {
            /*проверяем, что путь между вершинами есть
             * и она не посещенная.*/
            if (mas[v][i] == 1 && vertexList[i].isVisited == false) {
                /*если есть вершина, т.е. зашли в тело условия,
                 * то возвращаем вершину*/
                return i;
            }
        }
        /*Если сделали весь обход по всем вершинам, то вернем -1*/
        return -1;
    }

    /**
     * Метод обхода графа в глубину.
     *
     * @param index начальная вершина графа.
     */
    public void passInDeep(int index) {
        /*Напечатаем вершину:*/
        System.out.println(vertexList[index].name);
        /*Пометим вершину как посещенную.*/
        vertexList[index].isVisited = true;
        /*И заносим эту переменную в стек*/
        stack.push(index);
        /*Пока в стеке что то есть цикл крутится:*/
        while (!stack.isEmpty()) {
            /*В переменную neigh сохраняем вершину, которая
             * будет соседней  с А (это при первом проходе).
             * Т.е. смотрим на вершину лежащую
             * на верху стека и проверяем ее методом check().
             * Метод check() проверит и найдет вершину В.*/
            int neigh = check(stack.peek());

            /*Делаем проверку нашел ли метод непосещенную вершину
             * или нет.
             * Если Да, то:*/
            if (neigh == -1) {
                neigh = stack.pop();
            }
            /*Если нет, то:*/
            else {
                System.out.println(vertexList[neigh].name);
                vertexList[neigh].isVisited = true;
                stack.push(neigh);
            }
        }
        /*Хотим проштудировать все наши вершины разом.
         * Хотим обнулить все флажки.*/
        for (int i = 0; i < curN; i++) {
            /*Все привели к первоначальному состоянию.*/
            vertexList[i].isVisited = false;
        }
    }

    public void passInWidth(int index) {
        /*Напечатаем вершину:*/
        System.out.println(vertexList[index].name);
        /*Пометим вершину как посещенную.*/
        vertexList[index].isVisited = true;
        /*И заносим эту переменную в очередь*/
        queue.insert(index);

        /*Вершина*/
        int vertex;
        /*Пока очередь не пуста, то цикл крутится:*/
        while (!queue.isEmpty()) {
            /*Временная переменная в которую будем записывать то,
             * что извлекаем из очереди*/
            int temp = queue.remove();

            /*Ищем ближайших соседей к вершине и выводим их,
             * занося в очередь.*/
            while ((vertex = check(temp)) != -1) {
                System.out.println(vertexList[vertex].name);
                vertexList[vertex].isVisited = true;
                queue.insert(vertex);
            }
        }
        for (int i = 0; i < curN; i++) {
            vertexList[i].isVisited = false;
        }
    }

}
